import{initialise}from"./init.js";import{ESError,TypeError}from"./errors.js";import{Position}from"./position.js";import{ESArray,ESPrimitive,ESType,ESUndefined,types}from"./primitiveTypes.js";import{str}from"./util.js";export class ESSymbol{constructor(t,e,i={}){var n,s;this.value=t,this.identifier=e,this.isConstant=null!==(n=i.isConstant)&&void 0!==n&&n,this.isAccessible=null===(s=i.isAccessible)||void 0===s||s}}export class Context{constructor(){this.initialisedAsGlobal=!1,this.libs=[],this.deleted=!1,this.symbolTable={}}has(t){return void 0!==this.get(t)}hasOwn(t){return this.symbolTable[t]instanceof ESSymbol}get(t){let e=this.getSymbol(t);return e instanceof ESError||null==e?e:e.value}getSymbol(t){let e=this.symbolTable[t];if(void 0!==e&&!e.isAccessible)return new TypeError(Position.unknown,"assessable","inaccessible",e.identifier);if(void 0===e&&this.parent){let i=this.parent.getSymbol(t);if(i instanceof ESError)return i;e=i}return e}set(t,e,i={}){let n=this;if(i.global)n=this.root;else{for(;!n.hasOwn(t)&&void 0!==n.parent;)n=n.parent;n.hasOwn(t)||(n=this)}return n.setOwn(e,t,i)}setOwn(t,e,i={}){if(t instanceof ESPrimitive||(t=ESPrimitive.wrap(t)),i.global&&!this.initialisedAsGlobal&&(i.global=!1),!i.forceThroughConst){let t=this.symbolTable[e];if(null==t?void 0:t.isConstant)return new TypeError(Position.unknown,"dynamic","constant",e)}this.symbolTable[e]=new ESSymbol(t,e,i)}remove(t){delete this.symbolTable[t]}clear(){for(let t in this.symbolTable)this.remove(t);this.parent=void 0,this.deleted=!0}get root(){let t=this;for(;t.parent;)t=t.parent;return t}resetAsGlobal(){var t,e;if(!this.initialisedAsGlobal)return;const i=this.root.get("print"),n=this.root.get("input");i instanceof ESPrimitive&&n instanceof ESPrimitive?(this.symbolTable={},this.initialisedAsGlobal=!1,initialise(this,(null===(t=i.valueOf())||void 0===t?void 0:t.func)||console.log,(null===(e=n.valueOf())||void 0===e?void 0:e.func)||(()=>{}),this.libs)):console.error("Error with print and input functions.")}log(){console.log("---- CONTEXT ----");for(let t in this.symbolTable){const e=this.symbolTable[t];let i=t;e.isConstant&&(i+=" (CONST)"),e.isAccessible||(i+=" (INACCESSIBLE)"),i+=": ",i+=str(this.symbolTable[t].value),console.log(i)}console.log("-----------------")}}export function generateESFunctionCallContext(t,e,i){const n=new Context;n.parent=i;let s=Math.max(t.length,e.arguments_.length);for(let i=0;i<s;i++){let s=new ESUndefined,o=types.any;if(null==e.arguments_[i])continue;const r=e.arguments_[i];if(!(r.type instanceof ESType))return new TypeError(Position.unknown,"Type",typeof r.type,r.type);if(t[i]instanceof ESPrimitive&&(o=t[i].__type__,s=t[i]),!r.type.includesType(o))return new TypeError(Position.unknown,r.type.__name__,o.__name__);n.setOwn(s,r.name,{forceThroughConst:!0})}let o=n.setOwn(new ESArray(t),"args");return o instanceof ESError?o:n}