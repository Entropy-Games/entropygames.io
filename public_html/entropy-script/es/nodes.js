import{tokenTypeString,tt}from"./tokens.js";import{ESError,InvalidSyntaxError,ReferenceError,TypeError}from"./errors.js";import{Context}from"./context.js";import{Position}from"./position.js";import{None,now}from"./constants.js";import{interpretArgument}from"./argument.js";import{ESArray,ESBoolean,ESFunction,ESNumber,ESObject,ESPrimitive,ESString,ESType,ESUndefined,types}from"./primitiveTypes.js";export class interpretResult{constructor(){this.shouldBreak=!1,this.shouldContinue=!1}}export class Node{constructor(e,t=!1){this.startPos=e,this.isTerminal=t}interpret(e){const t=now(),r=new interpretResult,n=this.interpret_(e);n instanceof ESError?r.error=n:n instanceof interpretResult?(r.val=n.val,r.error=n.error,r.funcReturn=n.funcReturn,r.shouldBreak=n.shouldBreak,r.shouldContinue=n.shouldContinue):r.val=n;let o=now()-t;return Node.interprets++,Node.totalTime+=o,o>Node.maxTime&&(Node.maxTime=o),r}}Node.interprets=0,Node.totalTime=0,Node.maxTime=0;export class N_binOp extends Node{constructor(e,t,r,n){super(e),this.left=t,this.opTok=r,this.right=n}interpret_(e){const t=this.left.interpret(e),r=this.right.interpret(e);if(t.error)return t.error;if(r.error)return r.error;const n=t.val,o=r.val;if(void 0===n)return new TypeError(this.opTok.startPos,"~undefined","undefined",n,"N_binOp.interpret_");if(void 0===o)return new TypeError(this.opTok.startPos,"~undefined","undefined",o,"N_binOp.interpret_");function s(e,t,r,n){return e instanceof ESPrimitive&&t instanceof ESPrimitive&&e.hasProperty(new ESString(r))?e[r](t):new TypeError(n,"unknown",null==e?void 0:e.typeOf().valueOf(),null==e?void 0:e.valueOf(),`Unsupported operand for ${r}`)}switch(this.opTok.type){case tt.LTE:{const e=s(n,o,"__lt__",this.opTok.startPos),t=s(n,o,"__eq__",this.opTok.startPos);return e instanceof ESError?e:t instanceof ESError?t:s(e,t,"__or__",this.opTok.startPos)}case tt.GTE:{const e=s(n,o,"__gt__",this.opTok.startPos),t=s(n,o,"__eq__",this.opTok.startPos);return e instanceof ESError?e:t instanceof ESError?t:s(e,t,"__or__",this.opTok.startPos)}case tt.NOTEQUALS:{const e=s(n,o,"__eq__",this.opTok.startPos);return e instanceof ESError?e:new ESBoolean(!e.bool().valueOf())}case tt.ADD:return s(n,o,"__add__",this.opTok.startPos);case tt.SUB:return s(n,o,"__subtract__",this.opTok.startPos);case tt.MUL:return s(n,o,"__multiply__",this.opTok.startPos);case tt.DIV:return s(n,o,"__divide__",this.opTok.startPos);case tt.POW:return s(n,o,"__pow__",this.opTok.startPos);case tt.EQUALS:return s(n,o,"__eq__",this.opTok.startPos);case tt.LT:return s(n,o,"__lt__",this.opTok.startPos);case tt.GT:return s(n,o,"__gt__",this.opTok.startPos);case tt.AND:return s(n,o,"__and__",this.opTok.startPos);case tt.OR:return s(n,o,"__or__",this.opTok.startPos);default:return new InvalidSyntaxError(this.opTok.startPos,`Invalid binary operator: ${tokenTypeString[this.opTok.type]}`)}}}export class N_unaryOp extends Node{constructor(e,t,r){super(e),this.a=t,this.opTok=r}interpret_(e){var t,r,n;const o=this.a.interpret(e);if(o.error)return o.error;switch(this.opTok.type){case tt.SUB:case tt.ADD:if(!(o.val instanceof ESNumber))return new TypeError(this.startPos,"Number",(null===(t=o.val)||void 0===t?void 0:t.typeOf().toString())||"undefined_",null===(r=o.val)||void 0===r?void 0:r.valueOf());const e=o.val.valueOf();return new ESNumber(this.opTok.type===tt.SUB?-e:Math.abs(e));case tt.NOT:return new ESBoolean(!(null===(n=null==o?void 0:o.val)||void 0===n?void 0:n.bool().valueOf()));default:return new InvalidSyntaxError(this.opTok.startPos,`Invalid unary operator: ${tokenTypeString[this.opTok.type]}`)}}}export class N_varAssign extends Node{constructor(e,t,r,n="=",o=!1,s=!1,i=types.any){super(e),this.value=r,this.varNameTok=t,this.isGlobal=o,this.assignType=n,this.isConstant=s,this.type=i instanceof ESType?new N_any(i):i}interpret_(e){var t,r,n,o,s,i,a,l,u;const p=this.value.interpret(e),d=this.type.interpret(e);if(p.error)return p.error;if(d.error)return d.error;if(!(d.val&&d.val instanceof ESType))return new TypeError(this.varNameTok.startPos,"Type",null!==(r=null===(t=d.val)||void 0===t?void 0:t.typeOf().valueOf())&&void 0!==r?r:"undefined",null===(n=d.val)||void 0===n?void 0:n.str(),"@ !typeRes.val || !(typeRes.val instanceof ESType)");if(!p.val)return new TypeError(this.varNameTok.startPos,"~undefined","undefined","N_varAssign.interpret_");if(!d.val.includesType(p.val.__type__))return new TypeError(this.varNameTok.startPos,null!==(o=d.val.str().valueOf())&&void 0!==o?o:"unknown type",null!==(i=null===(s=p.val)||void 0===s?void 0:s.typeOf().valueOf())&&void 0!==i?i:"undefined__",null===(a=p.val)||void 0===a?void 0:a.str());if("="===this.assignType){let t=p.val;void 0===t&&(t=new ESUndefined);const r=e.set(this.varNameTok.value,t,{global:this.isGlobal,isConstant:this.isConstant});if(r instanceof ESError)return r}else{const t=null===(l=e.get(this.varNameTok.value))||void 0===l?void 0:l.valueOf();if(t instanceof ESError)return t;let r,n=null===(u=p.val)||void 0===u?void 0:u.valueOf();switch(this.assignType[0]){case"*":r=t*n;break;case"/":r=t/n;break;case"+":r=t+n;break;case"-":r=t-n;break;default:return new ESError(this.startPos,"AssignError",`Cannot find assignType of ${this.assignType[0]}`)}let o=e.set(this.varNameTok.value,r,{global:this.isGlobal,isConstant:this.isConstant});if(o instanceof ESError)return o;p.val=ESPrimitive.wrap(r)}return p}}export class N_if extends Node{constructor(e,t,r,n){super(e),this.comparison=t,this.ifFalse=n,this.ifTrue=r}interpret_(e){var t;let r=new Context;r.parent=e;let n=new interpretResult,o=this.comparison.interpret(e);if(o.error)return o;if(null===(t=o.val)||void 0===t?void 0:t.bool().valueOf()){if(n=this.ifTrue.interpret(r),n.val=new ESUndefined,n.error)return n}else if(this.ifFalse&&(n=this.ifFalse.interpret(r),n.val=new ESUndefined,n.error))return n;return n}}export class N_while extends Node{constructor(e,t,r){super(e),this.comparison=t,this.loop=r}interpret_(e){var t,r;let n=new Context;for(n.parent=e;;){let o=this.comparison.interpret(e);if(o.error)return o;if(!(null===(r=null===(t=o.val)||void 0===t?void 0:t.bool())||void 0===r?void 0:r.valueOf()))break;let s=this.loop.interpret(n);if(s.error)return s;if(s.shouldBreak)break}return new ESUndefined}}export class N_for extends Node{constructor(e,t,r,n,o,s){super(e),this.body=t,this.array=r,this.identifier=n,this.isGlobalId=o,this.isConstId=s}interpret_(e){var t,r,n,o,s,i,a,l;let u=new Context;u.parent=e;let p=None;const d=this.array.interpret(e);if(d.error)return d;if(!["Array","Number","Object","String","Any"].includes((null===(t=d.val)||void 0===t?void 0:t.typeOf().valueOf())||""))return new TypeError(this.identifier.startPos,"Array | Number | Object | String",typeof d.val+" | "+(null===(r=d.val)||void 0===r?void 0:r.typeOf()));function f(e,t,r,n,o){return u.set(t,r,{global:n,isConstant:o}),p=e.interpret(u),p.error||void 0!==p.funcReturn?p:p.shouldBreak?(p.shouldBreak=!1,"break"):void(p.shouldContinue&&(p.shouldContinue=!1))}if(d.val instanceof ESNumber||"number"==typeof(null===(n=d.val)||void 0===n?void 0:n.valueOf()))for(let e=0;e<d.val.valueOf();e++){const t=f(this.body,this.identifier.value,new ESNumber(e),this.isGlobalId,this.isConstId);if("break"===t)break;if(t&&(t.error||void 0!==t.funcReturn))return t}else if(d.val instanceof ESObject||"number"==typeof(null===(o=d.val)||void 0===o?void 0:o.valueOf())&&!Array.isArray(null===(s=d.val)||void 0===s?void 0:s.valueOf()))for(let e in null===(i=d.val)||void 0===i?void 0:i.valueOf()){const t=f(this.body,this.identifier.value,new ESString(e),this.isGlobalId,this.isConstId);if("break"===t)break;if(t&&(t.error||void 0!==t.funcReturn))return t}else{if(!(d.val instanceof ESArray||Array.isArray(null===(a=d.val)||void 0===a?void 0:a.valueOf())))return new TypeError(this.identifier.startPos,"Array | Number | Object | String",typeof d.val);for(let e of null===(l=d.val)||void 0===l?void 0:l.valueOf()){const t=f(this.body,this.identifier.value,e,this.isGlobalId,this.isConstId);if("break"===t)break;if(t&&(t.error||void 0!==t.funcReturn))return t}}return new ESUndefined}}export class N_array extends Node{constructor(e,t,r=!1){super(e),this.items=t,this.shouldClone=r}interpret_(e){let t=new interpretResult,r=[];for(let t of this.items){const n=t.interpret(e);if(n.error||void 0!==n.funcReturn)return n;if(!n.val)continue;let o=n.val;this.shouldClone&&(o=o.clone()),r.push(o)}return t.val=new ESArray(r),t}}export class N_objectLiteral extends Node{constructor(e,t){super(e),this.properties=t}interpret_(e){let t={};for(const[r,n]of this.properties){const o=n.interpret(e);if(o.error)return o.error;const s=r.interpret(e);if(s.error)return s.error;s.val&&o.val&&(t[s.val.valueOf()]=o.val)}return new ESObject(t)}}export class N_emptyObject extends Node{constructor(e){super(e)}interpret_(e){return new ESObject({})}}export class N_statements extends Node{constructor(e,t){super(e),this.items=t}interpret_(e){let t;for(let r of this.items){const n=r.interpret(e);if(n.error||void 0!==n.funcReturn||n.shouldBreak||n.shouldContinue)return n;t=n.val}return t||new ESUndefined}}export class N_functionCall extends Node{constructor(e,t,r){super(e),this.arguments=r,this.to=t}interpret_(e){let{val:t,error:r}=this.to.interpret(e);if(r)return r;if(!t)return new TypeError(this.startPos,"any","undefined",void 0,"On function call");if(!t.__call__)return new TypeError(this.startPos,"unknown",(null==t?void 0:t.typeOf().valueOf())||"unknown",null==t?void 0:t.valueOf(),"Can only () on something with __call__ property");let n=[];for(let t of this.arguments){const r=t.interpret(e);if(r.error)return r.error;r.val&&n.push(r.val)}return t.__call__(n,e)}}export class N_functionDefinition extends Node{constructor(e,t,r,n,o="(anon)",s=new ESObject){super(e),this.arguments=r,this.body=t,this.name=o,this.this_=s,this.returnType=n}interpret_(e){var t,r,n;let o=[];for(let t of this.arguments){const r=interpretArgument(t,e);if(r instanceof ESError)return r;o.push(r)}const s=this.returnType.interpret(e);return s.error?s.error:s.val instanceof ESType?new ESFunction(this.body,o,this.name,this.this_,s.val):new TypeError(this.returnType.startPos,"Type",null!==(r=null===(t=s.val)||void 0===t?void 0:t.typeOf().valueOf())&&void 0!==r?r:"<Undefined>",null===(n=s.val)||void 0===n?void 0:n.str().valueOf(),`On func '${this.name}' return type`)}}export class N_return extends Node{constructor(e,t){super(e),this.value=t}interpret_(e){const t=new interpretResult;if(void 0===this.value)return t.funcReturn=new ESUndefined,t;let r=this.value.interpret(e);return r.error?r.error:(t.funcReturn=r.val,t)}}export class N_yield extends Node{constructor(e,t){super(e),this.value=t}interpret_(e){var t;const r=new interpretResult;if(void 0===this.value)return r.funcReturn=new ESUndefined,r;let n=this.value.interpret(e);return n.error?n.error:((null===(t=n.val)||void 0===t?void 0:t.bool())&&(r.funcReturn=n.val),r)}}export class N_indexed extends Node{constructor(e,t,r){super(e),this.base=t,this.index=r}declaredBinOp(e,t,r,n){return e.hasProperty(new ESString(r))?e[r](t):new ESError(n,"TypeError",`Unsupported operand ${r} on type ${e.typeOf().valueOf()}`)}interpret_(e){var t;let r=this.base.interpret(e);if(r.error)return r;let n=this.index.interpret(e);if(n.error)return n;const o=n.val,s=r.val;if(!s||!o)return new ESUndefined;if(void 0!==this.value){let r=this.value.interpret(e);if(r.error)return r;const n=ESPrimitive.wrap(s.__getProperty__(o));let i,a=r.val;if(null!==(t=this.assignType)&&void 0!==t||(this.assignType="="),!a)return new TypeError(this.startPos,"~undefined","undefined","undefined","N_indexed.interpret_");switch(this.assignType[0]){case"*":i=this.declaredBinOp(n,a,"__multiply__",this.startPos);break;case"/":i=this.declaredBinOp(n,a,"__divide__",this.startPos);break;case"+":i=this.declaredBinOp(n,a,"__add__",this.startPos);break;case"-":i=this.declaredBinOp(n,a,"__subtract__",this.startPos);break;case"=":i=a;break;default:return new ESError(this.startPos,"AssignError",`Cannot find assignType of ${this.assignType[0]}`)}if(i instanceof ESError)return i;if(!s.__setProperty__)return new TypeError(this.startPos,"mutable","immutable",s.valueOf());const l=s.__setProperty__(o,null!=i?i:new ESUndefined);if(l instanceof ESError)return l}return ESPrimitive.wrap(s.__getProperty__(o))}}export class N_class extends Node{constructor(e,t,r,n,o="<anon class>"){super(e),this.init=n,this.methods=t,this.name=o,this.extends_=r,this.instances=[]}interpret_(e){var t,r,n;const o=[];for(let r of this.methods){const n=r.interpret(e);if(n.error)return n.error;if(!(n.val instanceof ESFunction))return new TypeError(this.startPos,"Function",(null===(t=n.val)||void 0===t?void 0:t.typeOf().valueOf())||"undefined","method on "+this.name);o.push(n.val)}let s,i;if(this.extends_){const t=this.extends_.interpret(e);if(t.error)return t.error;if(!(t.val instanceof ESType))return new TypeError(this.startPos,"Function",(null===(r=t.val)||void 0===r?void 0:r.typeOf().valueOf())||"undefined","method on "+this.name);s=t.val}if(this.init){const t=this.init.interpret(e);if(t.error)return t.error;if(!(t.val instanceof ESFunction))return new TypeError(this.startPos,"Function",(null===(n=t.val)||void 0===n?void 0:n.typeOf().valueOf())||"undefined","method on "+this.name);i=t.val}return new ESType(!1,this.name,o,s,i)}}export class N_number extends Node{constructor(e,t){super(e,!0),this.a=t}interpret_(e){let t=this.a.value;if("number"!=typeof t)return new TypeError(this.startPos,"number",typeof t);const r=new interpretResult;return r.val=new ESNumber(t),r}}export class N_string extends Node{constructor(e,t){super(e,!0),this.a=t}interpret_(e){let t=this.a.value;if("string"!=typeof t)return new TypeError(this.startPos,"string",typeof t);const r=new interpretResult;return r.val=new ESString(t),r}}export class N_variable extends Node{constructor(e){super(e.startPos,!0),this.a=e}interpret_(e){if(!e.has(this.a.value))return new ReferenceError(this.a.startPos,this.a.value);let t=new interpretResult,r=e.getSymbol(this.a.value);return r?r instanceof ESError?r:(t.val=r.value,t):new ESUndefined}}export class N_undefined extends Node{constructor(e=Position.unknown){super(e,!0)}interpret_(e){const t=new interpretResult;return t.val=new ESUndefined,t}}export class N_break extends Node{constructor(e){super(e,!0)}interpret_(e){const t=new interpretResult;return t.shouldBreak=!0,t}}export class N_continue extends Node{constructor(e){super(e,!0)}interpret_(e){const t=new interpretResult;return t.shouldContinue=!0,t}}export class N_any extends Node{constructor(e,t=Position.unknown){super(t,!0),this.val=e}interpret_(e){return this.val instanceof ESPrimitive?this.val:ESPrimitive.wrap(this.val)}}