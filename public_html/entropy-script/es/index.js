import"./colourString.js";import{Lexer}from"./lexer.js";import{Parser}from"./parser.js";import{global,now}from"./constants.js";import{initialise}from"./init.js";import{ESError}from"./errors.js";import{Position}from"./position.js";import{interpretResult,Node}from"./nodes.js";import{ESArray}from"./primitiveTypes.js";export function init(e=console.log,r,o){initialise(global,e,r,o)}export function run(e,{env:r=global,measurePerformance:o=!1}={}){Node.maxTime=0,Node.totalTime=0,Node.interprets=0;const t={total:0,lexerTotal:0,parserTotal:0,interpretTotal:0,nodeMax:0,nodeAvg:0,nodeTotal:0,interprets:0};let n=now();if(!r.root.initialisedAsGlobal){const e=new interpretResult;return e.error=new ESError(Position.unknown,"Uninitialised","Global context has not been initialised with global values"),e}const i=new Lexer(e),[s,a]=i.generate();if(a){const e=new interpretResult;return e.error=a,e}t.lexerTotal=now()-n,n=now();const l=new Parser(s).parse();if(l.error){const e=new interpretResult;return e.error=l.error,e}if(t.parserTotal=now()-n,n=now(),!l.node){const e=new interpretResult;return e.val=new ESArray([]),e}const p=l.node.interpret(r);return t.interpretTotal=now()-n,t.total=now()-n,t.nodeMax=Node.maxTime,t.nodeTotal=Node.totalTime,t.nodeAvg=Node.totalTime/Node.interprets,t.interprets=Node.interprets,o&&console.log(t),Object.assign(Object.assign({},p),{timeData:t})}